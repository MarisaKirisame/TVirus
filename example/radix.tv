data Radix a = Node(Radix, Radix, Radix, Radix) | Leaf(a)

let length = \t . (match t with
| Leaf() -> 1
| Node(_, t0, t1, t2, t3) -> 
  (((length(t0)) + (length(t1))) + ((length(t2)) + (length(t3)))))

let buildAux = \f, n, x4, k .
  if (k >= n) { Leaf() }
  else { 
    Node(
      f(k),
      buildAux(f, n, x4 * 4, k),
      buildAux(f, n, x4 * 4, k + 1 * x4),
      buildAux(f, n, x4 * 4, k + 2 * x4),
      buildAux(f, n, x4 * 4, k + 3 * x4)
    ) 
  }

let build = \f, n . buildAux(f, n, 1, 0)

let access = \t, n . 
  let kthSubTree = \t, k . match t with
  | Node(_, t0, t1, t2, t3) -> 
    (if       (k == 0) { t0 }
    else { if (k == 1) { t1 }
    else { if (k == 2) { t2 }
    else {               t3 } } })
  
  in if n == 0 { 
    match t with
    | Node(a, _, _, _, _) -> a
  }
  else {
    let sub = kthSubTree(t, (n % 4))
    in access(sub, n / 4)
  }

let modify = \t, n, f . 
  if n == 0 {
    match t with
    | Node(x,    t0, t1, t2, t3) ->
      Node(f(x), t0, t1, t2, t3)
  } 
  else {
    match t with
    | Node(x, t0, t1, t2, t3) -> 
      let k = (n % 4)
      in if        (k == 0) { Node(x, modify(t0, n / 4, f), t1, t2, t3) }
         else { if (k == 1) { Node(x, t0, modify(t1, n / 4, f), t2, t3) }
         else { if (k == 2) { Node(x, t0, t1, modify(t2, n / 4, f), t3) }
         else {               Node(x, t0, t1, t2, modify(t3, n / 4, f)) } } }
  }

let main = 
  let array = build(\x . x + 1, 40)
  in let newArray = modify(array, 3, (\a . (a - 1) + (access(array, 39))))
  in access(newArray, 3)
